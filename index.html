<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Metadata.dat Binary Inspector & Editor</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
<style>
  :root{--bg:#0f1724;--panel:#0b1220;--muted:#9aa6bf;--accent:#7dd3fc}
  body{margin:0;font-family:Inter,system-ui,Arial;background:linear-gradient(180deg,#071325,#071827);color:#e6eef8}
  .wrap{max-width:1100px;margin:24px auto;padding:18px;border-radius:12px;background:rgba(255,255,255,0.02)}
  header{display:flex;gap:12px;align-items:center}
  h1{margin:0;font-size:18px}
  .grid{display:grid;grid-template-columns:380px 1fr;gap:14px;margin-top:14px}
  .panel{background:var(--panel);padding:12px;border-radius:10px}
  .muted{color:var(--muted);font-size:13px}
  input, select, textarea, button{font:inherit}
  .filelabel{display:inline-flex;align-items:center;padding:8px;border-radius:8px;border:1px dashed rgba(255,255,255,0.04);cursor:pointer;background:transparent}
  textarea{width:100%;height:180px;background:transparent;color:inherit;border:1px dashed rgba(255,255,255,0.04);padding:10px;border-radius:8px;font-family:monospace}
  .list{height:420px;overflow:auto;margin-top:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.02);padding:8px;background:rgba(255,255,255,0.01)}
  .seg{padding:8px;border-radius:6px;margin-bottom:6px;background:rgba(255,255,255,0.01);cursor:pointer}
  .seg:hover{background:rgba(255,255,255,0.02)}
  .seg.sel{outline:2px solid rgba(125,211,252,0.12);background:linear-gradient(90deg, rgba(125,211,252,0.03), rgba(96,165,250,0.02))}
  .actions{display:flex;gap:8px;margin-top:8px;flex-wrap:wrap}
  .btn{padding:8px 12px;border-radius:8px;border:none;background:linear-gradient(180deg,var(--accent),#60a5fa);color:#042233;font-weight:600;cursor:pointer}
  .btn.alt{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted)}
  .small{font-size:13px}
  .preview{white-space:pre-wrap;background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;margin-top:8px;font-family:monospace}
  .footer{margin-top:12px;color:var(--muted);font-size:13px}
  @media (max-width:980px){ .grid{grid-template-columns:1fr} }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>Metadata.dat Binary Inspector & Editor</h1>
        <div class="muted">Load your <code>global-metadata.dat</code>, select an embedded metadata segment, edit, and download patched file ‚Äî client-side only.</div>
      </div>
      <div style="margin-left:auto" class="muted small">Local only ‚Ä¢ No uploads</div>
    </header>

    <div class="grid">
      <div class="panel">
        <label class="filelabel">üìÅ Load file <input id="fileInput" type="file" accept="*" style="display:none"/></label>
        <span style="margin-left:12px" id="fileInfo" class="muted small">No file loaded</span>

        <div style="margin-top:12px">
          <div class="muted small">Detected segments (click to inspect)</div>
          <div id="segList" class="list"></div>
        </div>

        <div style="margin-top:10px" class="actions">
          <button id="btnExtractAll" class="btn alt">Extract All Printable</button>
          <button id="btnTryGzip" class="btn alt">Detect & Try GZIP</button>
          <button id="btnFindBase64" class="btn alt">Find Base64</button>
        </div>

        <div style="margin-top:10px" class="muted">Diagnostics</div>
        <div id="diag" class="preview small"></div>
      </div>

      <div class="panel">
        <div style="display:flex;gap:12px;align-items:center">
          <div style="flex:1">
            <div class="muted small">Selected segment (editable)</div>
            <textarea id="txtSegment" placeholder="Select a detected segment to edit..."></textarea>
          </div>
          <div style="width:260px">
            <div class="muted small">Segment info</div>
            <div id="segInfo" class="preview small">No selection</div>

            <div style="margin-top:8px" class="actions">
              <button id="btnPatch" class="btn">Patch & Download</button>
              <button id="btnReplaceBytes" class="btn alt">Replace raw bytes</button>
            </div>

            <div style="margin-top:10px">
              <label class="small muted">When patching:</label>
              <div class="muted small">You may expand or shrink the file; splicing will produce a new file. Keep backups.</div>
            </div>

            <div style="margin-top:10px">
              <label class="small muted">Preview output</label>
              <div id="previewOut" class="preview small">‚Äî</div>
            </div>
          </div>
        </div>

      </div>
    </div>

    <div class="footer">
      Tip: If the segment is compressed (gzip) use "Detect & Try GZIP". If you don't get expected text, try "Find Base64" to decode embedded base64 blocks. Always keep original backups before writing patched files to your device.
    </div>
  </div>

<script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
<script>
/*
  Binary metadata editor - client-side only
  - detects printable sequences
  - attempts gzip decompress if header found
  - finds base64 blocks and decodes them
  - allows editing a selected segment and splicing it back into the binary and downloading
*/

const fileInput = document.getElementById('fileInput');
const fileInfo = document.getElementById('fileInfo');
const segList = document.getElementById('segList');
const diag = document.getElementById('diag');
const txtSegment = document.getElementById('txtSegment');
const segInfo = document.getElementById('segInfo');
const btnExtractAll = document.getElementById('btnExtractAll');
const btnTryGzip = document.getElementById('btnTryGzip');
const btnFindBase64 = document.getElementById('btnFindBase64');
const btnPatch = document.getElementById('btnPatch');
const btnReplaceBytes = document.getElementById('btnReplaceBytes');
const previewOut = document.getElementById('previewOut');

let currentFile = null;       // ArrayBuffer
let currentName = "";
let segments = [];            // {start, end, text, type}
let selectedIndex = -1;

function logd(s){ diag.textContent = s; }

fileInput.addEventListener('change', (e)=>{
  const f = e.target.files[0];
  if(!f) return;
  currentName = f.name;
  const reader = new FileReader();
  reader.onload = (ev)=>{
    currentFile = ev.target.result;
    fileInfo.textContent = `${currentName} ‚Äî ${currentFile.byteLength} bytes`;
    detectPrintableSegments();
  };
  reader.readAsArrayBuffer(f);
});

function isPrintableChar(c){
  return c >= 32 && c <= 126;
}

function detectPrintableSegments(minLen=16){
  segments = [];
  const bytes = new Uint8Array(currentFile);
  let i=0, N=bytes.length;
  while(i<N){
    // find run of printable chars
    if(isPrintableChar(bytes[i])){
      let j=i;
      while(j<N && (isPrintableChar(bytes[j]) || bytes[j]===9)) j++;
      if(j-i >= minLen){
        // decode this slice as latin1/utf8
        const slice = bytes.slice(i,j);
        let text;
        try { text = new TextDecoder('utf-8', {fatal:false}).decode(slice); }
        catch(e){ text = String.fromCharCode(...slice); }
        segments.push({start:i,end:j,text:typeSafeString(text),type:'printable'});
      }
      i=j;
    } else i++;
  }
  // also try to find embedded JSON-like shorter segments (>=8)
  const smallMin = 8;
  i=0;
  while(i<N){
    if(isPrintableChar(bytes[i])){
      let j=i; while(j<N && (isPrintableChar(bytes[j]) || bytes[j]===9)) j++;
      if(j-i >= smallMin){
        const slice = bytes.slice(i,j);
        let text;
        try { text = new TextDecoder('utf-8', {fatal:false}).decode(slice); }
        catch(e){ text = String.fromCharCode(...slice); }
        // only add if not already present (overlap)
        const overlap = segments.some(s=>!(j<=s.start || i>=s.end));
        if(!overlap) segments.push({start:i,end:j,text:typeSafeString(text), type:'printable'});
      }
      i=j;
    } else i++;
  }

  // sort by start
  segments.sort((a,b)=>a.start-b.start);
  renderSegmentList();
  logd(`Found ${segments.length} printable segments (minLen=${minLen}). Click one to inspect.`);
}

function typeSafeString(s){
  // remove long runs of weird control or nonprinting if any, keep readable portion
  return s.replace(/\x00/g,'').trim();
}

function renderSegmentList(){
  segList.innerHTML = '';
  if(!segments.length){ segList.textContent = 'No printable segments detected.'; return; }
  segments.forEach((seg, idx)=>{
    const el = document.createElement('div');
    el.className = 'seg' + (idx===selectedIndex? ' sel':'');
    el.innerHTML = `<div style="font-size:13px"><strong>Offset:</strong> ${seg.start} ‚Äî ${seg.end} (${seg.end-seg.start} bytes)</div>
                    <div style="margin-top:6px;color:var(--muted);font-family:monospace;white-space:nowrap;overflow:hidden;text-overflow:ellipsis">${seg.text.slice(0,260)}</div>`;
    el.addEventListener('click', ()=> { selectSegment(idx); });
    segList.appendChild(el);
  });
}

function selectSegment(i){
  selectedIndex = i;
  const s = segments[i];
  txtSegment.value = s.text;
  segInfo.textContent = `offset ${s.start} ‚Äî ${s.end} (${s.end-s.start} bytes)  type: ${s.type}`;
  renderSegmentList();
  updatePreviewOut(s.text);
}

function updatePreviewOut(txt){
  previewOut.textContent = txt.slice(0,2000);
}

// Try to detect gzip header anywhere and decompress chunk if found near printable region
btnTryGzip.addEventListener('click', ()=>{
  if(!currentFile) { logd('No file loaded'); return; }
  const bytes = new Uint8Array(currentFile);
  const gzOffsets = [];
  for(let i=0;i<bytes.length-2;i++){
    if(bytes[i]===0x1f && bytes[i+1]===0x8b){ gzOffsets.push(i); }
    if(gzOffsets.length>100) break;
  }
  if(gzOffsets.length===0){ logd('No gzip headers found (0x1f8b)'); return; }
  logd(`Found gzip headers at offsets: ${gzOffsets.slice(0,10).join(', ')} ‚Äî trying to decompress the first few...`);
  for(const off of gzOffsets.slice(0,6)){
    try {
      // find next printable region after offset, or try decompress from offset to end
      const slice = bytes.slice(off);
      const inflated = pako.ungzip(slice);
      let txt = new TextDecoder('utf-8', {fatal:false}).decode(inflated);
      txt = typeSafeString(txt);
      if(txt.length>0){
        // add to segments
        segments.push({start:off, end: off + slice.length, text: txt, type:'gzip'});
      }
    } catch(e){}
  }
  // sort unique
  segments.sort((a,b)=>a.start-b.start);
  renderSegmentList();
  logd(`Gzip search complete. Total segments now ${segments.length}. Select a gzip-derived segment to view text.`);
});

// Extract base64-like substrings from printable segments
btnFindBase64.addEventListener('click', ()=>{
  if(!segments.length){ logd('No printable segments to scan for base64.'); return; }
  let found = 0;
  const b64RE = /[A-Za-z0-9+/]{40,}={0,2}/g;
  for(let sidx=0;sidx<segments.length;sidx++){
    const seg=segments[sidx];
    const text = seg.text;
    const matches = text.match(b64RE) || [];
    matches.forEach(m=>{
      try {
        const decoded = atob(m);
        // if decoded has many printable characters, keep
        const printableCount = Array.from(decoded).filter(c=>c.charCodeAt(0)>=32 && c.charCodeAt(0)<=126).length;
        if(printableCount / decoded.length > 0.3){
          // add decoded as a new segment (embedding info where original came from)
          const fakeStart = seg.start; // can't know exact inner offset reliably
          segments.push({start:fakeStart, end: seg.end, text: decoded, type:'base64-decoded'});
          found++;
        }
      } catch(e){}
    });
  }
  segments.sort((a,b)=>a.start-b.start);
  renderSegmentList();
  logd(`Base64 scan complete. Added ${found} decoded candidates. Select one to edit.`);
});

// Extract All printable as a single big block (convenience)
btnExtractAll.addEventListener('click', ()=>{
  if(!currentFile){ logd('No file loaded'); return; }
  const bytes = new Uint8Array(currentFile);
  let out = '';
  for(let i=0;i<bytes.length;i++){
    if(isPrintableChar(bytes[i]) || bytes[i]===9) out += String.fromCharCode(bytes[i]);
    else out += ' ';
  }
  // collapse runs of spaces and show lines
  out = out.replace(/\s{3,}/g, '\n');
  // add as synthetic segment
  segments.push({start:0,end:bytes.length,text:typeSafeString(out),type:'all-printable'});
  renderSegmentList();
  logd('Extracted all printable characters into a single editable segment (bottom of list).');
});

// Patch: replace selected segment with new UTF-8 encoded bytes and offer download
btnPatch.addEventListener('click', ()=>{
  if(selectedIndex < 0) { logd('No segment selected'); return; }
  const seg = segments[selectedIndex];
  const newText = txtSegment.value;
  // encode newText as UTF-8
  const enc = new TextEncoder().encode(newText);
  spliceAndDownload(seg.start, seg.end, enc, `patched-${currentName}`);
});

// Replace raw bytes: user can paste hex string into the editor and click "Replace raw bytes"
btnReplaceBytes.addEventListener('click', ()=>{
  if(selectedIndex < 0) { logd('No segment selected'); return; }
  const seg = segments[selectedIndex];
  const raw = txtSegment.value.trim();
  // interpret as hex stream if contains hex chars and spaces
  let bytes = null;
  const hexOnly = raw.replace(/[^0-9a-fA-F]/g,'');
  if(hexOnly.length > 0 && hexOnly.length % 2 === 0 && hexOnly.length/2 < 5_000_000){
    // parse hex
    const arr = new Uint8Array(hexOnly.length/2);
    for(let i=0;i<arr.length;i++){ arr[i]=parseInt(hexOnly.substr(i*2,2),16); }
    bytes = arr;
  } else {
    // else treat as UTF-8 text
    bytes = new TextEncoder().encode(raw);
  }
  spliceAndDownload(seg.start, seg.end, bytes, `patched-${currentName}`);
});

function spliceAndDownload(start, end, newBytes, outName){
  const orig = new Uint8Array(currentFile);
  const before = orig.slice(0,start);
  const after = orig.slice(end);
  const out = new Uint8Array(before.length + newBytes.length + after.length);
  out.set(before, 0);
  out.set(newBytes, before.length);
  out.set(after, before.length + newBytes.length);
  const blob = new Blob([out], {type:'application/octet-stream'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = outName;
  document.body.appendChild(a); a.click(); a.remove();
  URL.revokeObjectURL(url);
  logd(`Patched bytes ${start}-${end} -> new length ${newBytes.length}. Download ready: ${outName}`);
}

function atobSafe(s){
  try { return atob(s); } catch(e) { return null; }
}
</script>
</body>
</html>

<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Metadata.dat Binary Inspector & Editor ‚Äî Optimized + Binary Save</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
<style>
  :root{--bg:#0f1724;--panel:#0b1220;--muted:#9aa6bf;--accent:#7dd3fc}
  body{margin:0;font-family:Inter,system-ui,Arial;background:linear-gradient(180deg,#071325,#071827);color:#e6eef8}
  .wrap{max-width:1100px;margin:20px auto;padding:16px;border-radius:12px;background:rgba(255,255,255,0.02)}
  header{display:flex;gap:12px;align-items:center}
  h1{margin:0;font-size:18px}
  .grid{display:grid;grid-template-columns:380px 1fr;gap:14px;margin-top:14px}
  .panel{background:var(--panel);padding:12px;border-radius:10px}
  .muted{color:var(--muted);font-size:13px}
  input, select, textarea, button{font:inherit}
  .filelabel{display:inline-flex;align-items:center;padding:8px;border-radius:8px;border:1px dashed rgba(255,255,255,0.04);cursor:pointer;background:transparent}
  textarea{width:100%;height:190px;background:transparent;color:inherit;border:1px dashed rgba(255,255,255,0.04);padding:10px;border-radius:8px;font-family:monospace;resize:vertical}
  .list{height:420px;overflow:auto;margin-top:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.02);padding:6px;background:rgba(255,255,255,0.01)}
  .seg{padding:8px;border-radius:6px;margin-bottom:6px;background:rgba(255,255,255,0.01);cursor:pointer}
  .seg:hover{background:rgba(255,255,255,0.02)}
  .seg.sel{outline:2px solid rgba(125,211,252,0.12);background:linear-gradient(90deg, rgba(125,211,252,0.03), rgba(96,165,250,0.02))}
  .actions{display:flex;gap:8px;margin-top:8px;flex-wrap:wrap}
  .btn{padding:8px 12px;border-radius:8px;border:none;background:linear-gradient(180deg,var(--accent),#60a5fa);color:#042233;font-weight:600;cursor:pointer}
  .btn.alt{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted)}
  .small{font-size:13px}
  .preview{white-space:pre-wrap;background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;margin-top:8px;font-family:monospace;max-height:240px;overflow:auto}
  .footer{margin-top:12px;color:var(--muted);font-size:13px}
  .top-row{display:flex;gap:8px;align-items:center}
  .search{flex:1;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit}
  .label-small{font-size:12px;color:var(--muted)}
  @media (max-width:980px){ .grid{grid-template-columns:1fr} .list{height:260px} .preview{max-height:160px} }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>Metadata.dat Binary Inspector & Editor</h1>
        <div class="muted">Load <code>global-metadata.dat</code>, edit embedded segments, patch & download ‚Äî client-side only.</div>
      </div>
      <div style="margin-left:auto" class="muted small">Local only ‚Ä¢ No uploads</div>
    </header>

    <div class="grid">
      <div class="panel">
        <div class="top-row" style="margin-bottom:10px">
          <label class="filelabel">üìÅ Load file <input id="fileInput" type="file" accept="*" style="display:none"/></label>
          <span id="fileInfo" class="muted small">No file loaded</span>
        </div>

        <div style="display:flex;gap:8px;align-items:center;margin-bottom:8px">
          <input id="segSearch" class="search" placeholder="Search segments (text or offset)..." />
          <button id="btnSearchClear" class="btn alt" title="Clear search">‚úñ</button>
        </div>

        <div style="display:flex;gap:8px;align-items:center;justify-content:space-between">
          <div class="label-small">Detected segments (click to inspect)</div>
          <div class="label-small muted">MinLen:
            <input id="minLen" type="number" value="24" style="width:64px;margin-left:6px;padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit" />
          </div>
        </div>

        <div id="segList" class="list" aria-live="polite"></div>

        <div class="actions" style="margin-top:8px">
          <button id="btnExtractAll" class="btn alt">Extract All Printable</button>
          <button id="btnTryGzip" class="btn alt">Detect & Try GZIP</button>
          <button id="btnFindBase64" class="btn alt">Find Base64</button>
          <button id="btnLoadMore" class="btn alt">Load more</button>
        </div>

        <div style="margin-top:10px">
          <div class="label-small muted">Diagnostics</div>
          <div id="diag" class="preview small" style="max-height:120px"></div>
        </div>
      </div>

      <div class="panel">
        <div style="display:flex;gap:12px;align-items:flex-start">
          <div style="flex:1">
            <div class="label-small muted">Selected segment (editable)</div>
            <textarea id="txtSegment" placeholder="Select a detected segment to edit..."></textarea>
            <div style="display:flex;gap:8px;margin-top:8px;align-items:center">
              <button id="btnSaveToMemory" class="btn">Save (apply to memory)</button>
              <button id="btnUndoSave" class="btn alt">Undo last save</button>
              <button id="btnPatchDownload" class="btn">Download patched file</button>
              <button id="btnPatchSegment" class="btn alt">Download segment-patch</button>
              <div style="margin-left:auto" class="label-small muted">Edits not saved until you click Save</div>
            </div>
          </div>

          <div style="width:300px">
            <div class="label-small muted">Segment info</div>
            <div id="segInfo" class="preview small">No selection</div>

            <div style="margin-top:8px">
              <div class="label-small muted">Preview output</div>
              <div id="previewOut" class="preview small">‚Äî</div>
            </div>
          </div>
        </div>

        <div style="margin-top:10px" class="muted small">Tip: Save applies your edits into memory so you can patch multiple segments and download a single patched file. Use Undo if you need to revert the last save.</div>
      </div>
    </div>

    <div class="footer">Keep backups before writing files back to the game. Use an alternate device/account for testing.</div>
  </div>

<script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
<script>
/* Full updated editor with binary-safe save + gzip/base64 re-encode */

const fileInput = document.getElementById('fileInput');
const fileInfo = document.getElementById('fileInfo');
const segList = document.getElementById('segList');
const diag = document.getElementById('diag');
const txtSegment = document.getElementById('txtSegment');
const segInfo = document.getElementById('segInfo');
const btnExtractAll = document.getElementById('btnExtractAll');
const btnTryGzip = document.getElementById('btnTryGzip');
const btnFindBase64 = document.getElementById('btnFindBase64');
const btnPatchDownload = document.getElementById('btnPatchDownload');
const btnPatchSegment = document.getElementById('btnPatchSegment');
const btnSaveToMemory = document.getElementById('btnSaveToMemory');
const btnUndoSave = document.getElementById('btnUndoSave');
const previewOut = document.getElementById('previewOut');
const segSearch = document.getElementById('segSearch');
const btnSearchClear = document.getElementById('btnSearchClear');
const minLenInput = document.getElementById('minLen');
const btnLoadMore = document.getElementById('btnLoadMore');

let currentFile = null;       // ArrayBuffer
let originalFile = null;
let currentName = "";
let segments = [];            // {start,end,text,type}
let displayedCount = 100;
let selectedIndex = -1;
let lastSaveBackup = null;
let searchTerm = "";

// helpers
function logd(s){ diag.textContent = s; }
function isPrintableChar(c){ return c >= 32 && c <= 126; }
function typeSafeString(s){ return String(s).replace(/\x00/g,'').trim(); }
const utf8Decoder = new TextDecoder('utf-8', {fatal:false});
const utf8Encoder = new TextEncoder();

function decodeUtf8(slice){ return utf8Decoder.decode(slice); }
function encodeUtf8(str){ return utf8Encoder.encode(String(str)); }

function getPatchedFilename(baseName) {
  if (!baseName) return "patched.dat";
  if (baseName.includes(".")) {
    const parts = baseName.split(".");
    parts[0] = "patched-" + parts[0];
    return parts.join(".");
  }
  return "patched-" + baseName + ".dat";
}

function spliceArrayBuffer(arrayBuffer, start, end, newUint8) {
  const orig = new Uint8Array(arrayBuffer);
  const before = orig.slice(0, start);
  const after = orig.slice(end);
  const out = new Uint8Array(before.length + newUint8.length + after.length);
  out.set(before, 0);
  out.set(newUint8, before.length);
  out.set(after, before.length + newUint8.length);
  return out.buffer;
}

// chunked detection (non-blocking)
function detectPrintableSegmentsChunked(minLen=24){
  detectJobToken = (detectJobToken || 0) + 1;
  const jobToken = detectJobToken;
  segments = [];
  selectedIndex = -1;
  segList.innerHTML = '';
  txtSegment.value = '';
  segInfo.textContent = 'No selection';
  previewOut.textContent = '‚Äî';
  logd('Scanning file for printable segments...');

  const bytes = new Uint8Array(currentFile);
  const N = bytes.length;
  let i = 0;
  const chunkSize = 200000;
  function processChunk(){
    if (jobToken !== detectJobToken) return;
    const end = Math.min(i + chunkSize, N);
    let cursor = i;
    while(cursor < end){
      if(isPrintableChar(bytes[cursor]) || bytes[cursor]===9){
        let j = cursor;
        while(j < N && (isPrintableChar(bytes[j]) || bytes[j]===9)) j++;
        if(j - cursor >= minLen){
          const slice = bytes.slice(cursor, j);
          let text;
          try { text = decodeUtf8(slice); } catch(e){ text = String.fromCharCode.apply(null, slice); }
          segments.push({start:cursor, end:j, text:typeSafeString(text), type:'printable'});
        }
        cursor = j;
      } else cursor++;
    }
    i = end;
    if(i % (chunkSize*4) === 0 || i >= N) renderSegmentList(true);
    if(i < N) setTimeout(processChunk, 12);
    else secondarySmallScan(8, jobToken);
  }
  processChunk();
}

function secondarySmallScan(minSmall, jobToken){
  const bytes = new Uint8Array(currentFile);
  const N = bytes.length;
  let i = 0;
  while(i < N){
    if(jobToken !== detectJobToken) return;
    if(isPrintableChar(bytes[i])){
      let j = i;
      while(j < N && (isPrintableChar(bytes[j]) || bytes[j]===9)) j++;
      if(j - i >= minSmall){
        const overlap = segments.some(s => !(j <= s.start || i >= s.end));
        if(!overlap){
          const slice = bytes.slice(i,j);
          let text;
          try { text = decodeUtf8(slice); } catch(e){ text = String.fromCharCode.apply(null, slice); }
          segments.push({start:i, end:j, text:typeSafeString(text), type:'printable'});
        }
      }
      i = j;
    } else i++;
  }
  segments.sort((a,b)=>a.start-b.start);
  renderSegmentList(false);
  logd(`Scan complete. Found ${segments.length} segments.`);
}

function renderSegmentList(incremental=false){
  segList.innerHTML = '';
  if(!segments.length){ segList.textContent = 'No printable segments detected.'; return; }
  const filtered = filterSegmentsBySearch();
  const toShow = filtered.slice(0, displayedCount);
  const frag = document.createDocumentFragment();
  for(let idx=0; idx<toShow.length; idx++){
    const seg = toShow[idx];
    const el = document.createElement('div');
    const isSel = selectedIndex >= 0 && segments[selectedIndex].start === seg.start && segments[selectedIndex].end === seg.end && segments[selectedIndex].text === seg.text;
    el.className = 'seg' + (isSel ? ' sel' : '');
    el.innerHTML = `<div style="font-size:13px"><strong>Offset:</strong> ${seg.start} ‚Äî ${seg.end} (${seg.end-seg.start} bytes)</div>
                    <div style="margin-top:6px;color:var(--muted);font-family:monospace;white-space:nowrap;overflow:hidden;text-overflow:ellipsis">${seg.text.slice(0,260)}</div>`;
    (function(localIdx){
      el.addEventListener('click', ()=> { selectSegmentByFilteredIndex(localIdx); });
    })(idx);
    frag.appendChild(el);
  }
  segList.appendChild(frag);
  if(filtered.length > displayedCount){
    const more = document.createElement('div');
    more.style.textAlign='center';
    more.innerHTML = `<button class="btn alt" id="btnMoreInner">Show ${filtered.length - displayedCount} more</button>`;
    segList.appendChild(more);
    document.getElementById('btnMoreInner').addEventListener('click', ()=>{
      displayedCount += 200; renderSegmentList();
    });
  }
}

function filterSegmentsBySearch(){
  const term = (segSearch.value || '').trim().toLowerCase();
  if(!term) return segments;
  const num = parseInt(term, 10);
  return segments.filter(s=>{
    if(!isNaN(num) && s.start === num) return true;
    if(s.start.toString().includes(term) || s.end.toString().includes(term)) return true;
    if(s.text.toLowerCase().includes(term)) return true;
    return false;
  });
}

function selectSegmentByFilteredIndex(filteredIdx){
  const filtered = filterSegmentsBySearch();
  const seg = filtered[filteredIdx];
  if(!seg) return;
  const realIdx = segments.findIndex(s => s.start===seg.start && s.end===seg.end && s.text===seg.text);
  if(realIdx < 0) return;
  selectedIndex = realIdx;
  selectSegment(realIdx);
}

function selectSegment(i){
  const s = segments[i];
  if(!s) return;
  txtSegment.value = s.text;
  segInfo.textContent = `offset ${s.start} ‚Äî ${s.end} (${s.end-s.start} bytes)  type: ${s.type}`;
  previewOut.textContent = s.text.slice(0,2000);
  renderSegmentList();
}

segSearch.addEventListener('input', debounce(()=>{ displayedCount = 100; renderSegmentList(); }, 220));
btnSearchClear.addEventListener('click', ()=>{ segSearch.value=''; renderSegmentList(); });

minLenInput.addEventListener('change', ()=>{ if(currentFile) detectPrintableSegmentsChunked(parseInt(minLenInput.value || 24,10)); });
btnLoadMore.addEventListener('click', ()=>{ displayedCount += 200; renderSegmentList(); });

fileInput.addEventListener('change', (e)=>{
  const f = e.target.files[0];
  if(!f) return;
  currentName = f.name;
  const reader = new FileReader();
  reader.onload = (ev)=> {
    currentFile = ev.target.result;
    originalFile = currentFile.slice(0);
    fileInfo.textContent = `${currentName} ‚Äî ${currentFile.byteLength} bytes`;
    detectPrintableSegmentsChunked(parseInt(minLenInput.value || 24,10));
  };
  reader.readAsArrayBuffer(f);
});

// convenience: extract all printable
btnExtractAll.addEventListener('click', ()=>{
  if(!currentFile){ logd('No file loaded'); return; }
  const bytes = new Uint8Array(currentFile);
  let out = '';
  for(let i=0;i<bytes.length;i++) out += (isPrintableChar(bytes[i]) || bytes[i]===9) ? String.fromCharCode(bytes[i]) : ' ';
  out = out.replace(/\s{3,}/g, '\n');
  segments.push({start:0,end:bytes.length,text:typeSafeString(out),type:'all-printable'});
  renderSegmentList();
  logd('Extracted all printable characters into a single editable segment.');
});

// gzip detection and decompression attempts
btnTryGzip.addEventListener('click', ()=>{
  if(!currentFile){ logd('No file loaded'); return; }
  const bytes = new Uint8Array(currentFile);
  const gzOffsets = [];
  for(let i=0;i<bytes.length-2;i++){
    if(bytes[i]===0x1f && bytes[i+1]===0x8b) gzOffsets.push(i);
    if(gzOffsets.length>100) break;
  }
  if(gzOffsets.length===0){ logd('No gzip headers found (0x1f8b)'); return; }
  logd(`Found gzip headers at offsets: ${gzOffsets.slice(0,10).join(', ')} ‚Äî trying to decompress the first few...`);
  let added = 0;
  for(const off of gzOffsets.slice(0,6)){
    try {
      const slice = bytes.slice(off);
      const inflated = pako.ungzip(slice);
      let txt = decodeUtf8(inflated);
      txt = typeSafeString(txt);
      if(txt.length>0){
        segments.push({start:off, end: off + slice.length, text: txt, type:'gzip'});
        added++;
      }
    } catch(e){}
  }
  segments.sort((a,b)=>a.start-b.start);
  renderSegmentList();
  logd(`Gzip search complete. Added ${added} candidates. Select one to view text.`);
});

// base64 decode scanning
btnFindBase64.addEventListener('click', ()=>{
  if(!segments.length){ logd('No printable segments to scan for base64.'); return; }
  let found = 0;
  const b64RE = /[A-Za-z0-9+/]{40,}={0,2}/g;
  for(let sidx=0;sidx<segments.length;sidx++){
    const seg = segments[sidx];
    const matches = (seg.text.match(b64RE) || []);
    matches.forEach(m=>{
      try {
        const decoded = atob(m);
        const printableCount = Array.from(decoded).filter(c=>c.charCodeAt(0)>=32 && c.charCodeAt(0)<=126).length;
        if(printableCount / decoded.length > 0.3){
          segments.push({start:seg.start, end:seg.end, text:typeSafeString(decoded), type:'base64-decoded'});
          found++;
        }
      } catch(e){}
    });
  }
  segments.sort((a,b)=>a.start-b.start);
  renderSegmentList();
  logd(`Base64 scan complete. Added ${found} decoded candidates. Select one to edit.`);
});

// helper to prepare bytes for insertion given a segment and edited text
function prepareBytesForSegment(seg, editedText){
  if(!seg) return null;
  try {
    if(seg.type === 'gzip'){
      // compress editedText as gzip of UTF-8 bytes
      const utf8 = encodeUtf8(editedText);
      const gz = pako.gzip(utf8);
      return gz; // Uint8Array
    } else if(seg.type === 'base64-decoded'){
      // re-encode to base64 and write ASCII bytes of the base64 string
      const b64 = btoa(editedText);
      return encodeUtf8(b64);
    } else {
      // plain text -> UTF-8 bytes
      return encodeUtf8(editedText);
    }
  } catch(e){
    logd('prepareBytesForSegment failed: ' + e);
    return null;
  }
}

// Save edits into memory (apply to currentFile) ‚Äî binary-safe with gzip/base64 handling
btnSaveToMemory.addEventListener('click', ()=>{
  if(selectedIndex < 0){ logd('No segment selected'); return; }
  const seg = segments[selectedIndex];
  const edited = txtSegment.value;
  const newBytes = prepareBytesForSegment(seg, edited);
  if(!newBytes){ logd('Failed to prepare bytes for saving.'); return; }

  // backup for undo
  lastSaveBackup = currentFile.slice(0);

  // splice
  currentFile = spliceArrayBuffer(currentFile, seg.start, seg.end, newBytes);

  // update segment meta and shift later segments
  const delta = newBytes.length - (seg.end - seg.start);
  seg.end = seg.start + newBytes.length;
  seg.text = edited;
  for(let i=0;i<segments.length;i++){
    if(segments[i].start > seg.start){
      segments[i].start += delta;
      segments[i].end += delta;
    }
  }
  renderSegmentList();
  logd(`Saved edits to memory. New file length: ${currentFile.byteLength} bytes.`);
});

// Undo last save (one-level)
btnUndoSave.addEventListener('click', ()=>{
  if(!lastSaveBackup){ logd('No undo available'); return; }
  currentFile = lastSaveBackup.slice(0);
  lastSaveBackup = null;
  detectPrintableSegmentsChunked(parseInt(minLenInput.value || 24,10));
  logd('Reverted last save (restored file in memory).');
});

// Download patched whole file (currentFile may be original or modified after Save)
btnPatchDownload.addEventListener('click', ()=>{
  if(!currentFile){ logd('No file loaded'); return; }
  const filename = getPatchedFilename(currentName);
  const blob = new Blob([currentFile], {type:'application/octet-stream'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = filename;
  document.body.appendChild(a); a.click(); a.remove();
  URL.revokeObjectURL(url);
  logd('Download started for patched file: ' + filename);
});

// Patch and download only the selected segment (spliced into file and returned)
btnPatchSegment.addEventListener('click', ()=>{
  if(selectedIndex < 0){ logd('No segment selected'); return; }
  const seg = segments[selectedIndex];
  const edited = txtSegment.value;
  const newBytes = prepareBytesForSegment(seg, edited);
  if(!newBytes){ logd('Failed to prepare bytes for segment patch.'); return; }

  // splice and download
  const orig = new Uint8Array(currentFile);
  const before = orig.slice(0, seg.start);
  const after = orig.slice(seg.end);
  const out = new Uint8Array(before.length + newBytes.length + after.length);
  out.set(before, 0);
  out.set(newBytes, before.length);
  out.set(after, before.length + newBytes.length);
  const blob = new Blob([out.buffer], {type:'application/octet-stream'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = `patched-segment-${currentName}`;
  document.body.appendChild(a); a.click(); a.remove();
  URL.revokeObjectURL(url);
  logd('Segment patched and download started.');
});

// utility: debounce
function debounce(fn, wait){ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a), wait); }; }

// initial UI ready
logd('Editor ready ‚Äî load a metadata file to start.');
</script>
</body>
</html>

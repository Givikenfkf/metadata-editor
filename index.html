<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Metadata.dat Binary Inspector & Editor ‚Äî Optimized + Binary Save</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
<style>
  :root{--bg:#0f1724;--panel:#0b1220;--muted:#9aa6bf;--accent:#7dd3fc}
  body{margin:0;font-family:Inter,system-ui,Arial;background:linear-gradient(180deg,#071325,#071827);color:#e6eef8}
  .wrap{max-width:1100px;margin:20px auto;padding:16px;border-radius:12px;background:rgba(255,255,255,0.02)}
  header{display:flex;gap:12px;align-items:center}
  h1{margin:0;font-size:18px}
  .grid{display:grid;grid-template-columns:380px 1fr;gap:14px;margin-top:14px}
  .panel{background:var(--panel);padding:12px;border-radius:10px}
  .muted{color:var(--muted);font-size:13px}
  input, select, textarea, button{font:inherit}
  .filelabel{display:inline-flex;align-items:center;padding:8px;border-radius:8px;border:1px dashed rgba(255,255,255,0.04);cursor:pointer;background:transparent}
  textarea{width:100%;height:190px;background:transparent;color:inherit;border:1px dashed rgba(255,255,255,0.04);padding:10px;border-radius:8px;font-family:monospace;resize:vertical}
  .list{height:420px;overflow:auto;margin-top:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.02);padding:6px;background:rgba(255,255,255,0.01)}
  .seg{padding:8px;border-radius:6px;margin-bottom:6px;background:rgba(255,255,255,0.01);cursor:pointer}
  .seg:hover{background:rgba(255,255,255,0.02)}
  .seg.sel{outline:2px solid rgba(125,211,252,0.12);background:linear-gradient(90deg, rgba(125,211,252,0.03), rgba(96,165,250,0.02))}
  .actions{display:flex;gap:8px;margin-top:8px;flex-wrap:wrap}
  .btn{padding:8px 12px;border-radius:8px;border:none;background:linear-gradient(180deg,var(--accent),#60a5fa);color:#042233;font-weight:600;cursor:pointer}
  .btn.alt{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted)}
  .small{font-size:13px}
  .preview{white-space:pre-wrap;background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;margin-top:8px;font-family:monospace;max-height:240px;overflow:auto}
  .footer{margin-top:12px;color:var(--muted);font-size:13px}
  .top-row{display:flex;gap:8px;align-items:center}
  .search{flex:1;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit}
  .label-small{font-size:12px;color:var(--muted)}
  .meta-row{display:flex;gap:8px;align-items:center;margin-top:8px}
  .small-muted{font-size:12px;color:var(--muted)}
  @media (max-width:980px){ .grid{grid-template-columns:1fr} .list{height:260px} .preview{max-height:160px} }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>Metadata.dat Binary Inspector & Editor</h1>
        <div class="muted">Load <code>global-metadata.dat</code>, inspect & edit embedded segments, save ‚Äî client-side only.</div>
      </div>
      <div style="margin-left:auto" class="muted small">Local only ‚Ä¢ No uploads</div>
    </header>

    <div class="grid">
      <div class="panel">
        <div class="top-row" style="margin-bottom:10px">
          <label class="filelabel">üìÅ Load file <input id="fileInput" type="file" accept="*" style="display:none"/></label>
          <span id="fileInfo" class="muted small">No file loaded</span>
        </div>

        <div style="display:flex;gap:8px;align-items:center;margin-bottom:8px">
          <input id="segSearch" class="search" placeholder="Search segments (text or offset)..." />
          <button id="btnSearchClear" class="btn alt" title="Clear search">‚úñ</button>
        </div>

        <div style="display:flex;gap:8px;align-items:center;justify-content:space-between">
          <div class="label-small">Detected segments (click to inspect)</div>
          <div class="label-small muted">MinLen:
            <input id="minLen" type="number" value="24" style="width:64px;margin-left:6px;padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit" />
          </div>
        </div>

        <div id="segList" class="list" aria-live="polite"></div>

        <div class="actions" style="margin-top:8px">
          <button id="btnRescan" class="btn alt">Rescan</button>
          <button id="btnExtractAll" class="btn alt">Extract All Printable</button>
          <button id="btnLoadMore" class="btn alt">Load more</button>
        </div>

        <div style="margin-top:10px">
          <div class="label-small muted">Diagnostics</div>
          <div id="diag" class="preview small" style="max-height:120px"></div>
        </div>
      </div>

      <div class="panel">
        <div style="display:flex;gap:12px;align-items:flex-start">
          <div style="flex:1">
            <div class="meta-row">
              <div class="small-muted">Selected segment:</div>
              <div id="selInfo" style="font-family:monospace;margin-left:8px">(none)</div>
            </div>

            <div style="margin-top:8px">
              <textarea id="editArea" placeholder="Select a segment from the left to edit..." style="height:220px"></textarea>
            </div>

            <div style="display:flex;gap:8px;align-items:center;margin-top:8px">
              <button id="btnApply" class="btn">Apply (in-place)</button>
              <label class="btn alt" style="display:inline-flex;align-items:center;gap:8px;padding:6px 10px"><input id="allowGrow" type="checkbox" style="margin-right:6px"/> Allow grow (insert)</label>
              <button id="btnHexEdit" class="btn alt">Switch to hex edit</button>
              <div style="margin-left:auto" class="small-muted">Encoding: <span id="encLabel">-</span></div>
            </div>

            <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
              <button id="btnDownload" class="btn">Download patched file</button>
              <button id="btnRevert" class="btn alt">Revert to original</button>
              <div style="margin-left:auto" class="small-muted">File bytes: <span id="fileSize">0</span></div>
            </div>

            <div style="margin-top:10px">
              <div class="label-small muted">Preview / Full content</div>
              <div id="fullPreview" class="preview"></div>
            </div>

            <div class="footer">Notes: in-place edits preserve offsets. If you choose "Allow grow" the file will be rebuilt by inserting bytes at the edited offset ‚Äî this shifts later offsets and may break some binary formats. Use with caution.</div>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
// Utility helpers
function isPrintable(b){ return b >= 32 && b <= 126; }
function decodeAscii(bytes){
  // map bytes directly to characters 0-255 using latin1
  const decoder = new TextDecoder('latin1');
  return decoder.decode(bytes);
}
function decodeUtf16le(bytes){
  const decoder = new TextDecoder('utf-16le');
  return decoder.decode(bytes);
}
function encodeAsciiStr(s){
  // produce single-byte array; characters outside 0..255 are replaced
  const arr = new Uint8Array(s.length);
  for(let i=0;i<s.length;i++){ let c = s.charCodeAt(i); arr[i] = (c & 0xFF); }
  return arr;
}
function encodeUtf16leStr(s){
  // little-endian 2 bytes per char
  const out = new Uint8Array(s.length*2);
  for(let i=0;i<s.length;i++){ const c=s.charCodeAt(i); out[i*2]=c&0xFF; out[i*2+1]=(c>>8)&0xFF; }
  return out;
}

let originalBuffer = null; // ArrayBuffer
let fileBuffer = null; // Uint8Array (mutable copy)
let segments = []; // detected segments
let displayLimit = 500;
let currentSelected = null; // {offset,length,text,encoding}

// DOM refs
const fileInput = document.getElementById('fileInput');
const fileInfo = document.getElementById('fileInfo');
const segList = document.getElementById('segList');
const diag = document.getElementById('diag');
const minLenInput = document.getElementById('minLen');
const segSearch = document.getElementById('segSearch');
const btnSearchClear = document.getElementById('btnSearchClear');
const editArea = document.getElementById('editArea');
const btnApply = document.getElementById('btnApply');
const btnDownload = document.getElementById('btnDownload');
const btnRescan = document.getElementById('btnRescan');
const encLabel = document.getElementById('encLabel');
const selInfo = document.getElementById('selInfo');
const fullPreview = document.getElementById('fullPreview');
const fileSizeLabel = document.getElementById('fileSize');
const allowGrow = document.getElementById('allowGrow');
const btnHexEdit = document.getElementById('btnHexEdit');
const btnRevert = document.getElementById('btnRevert');
const btnExtractAll = document.getElementById('btnExtractAll');
const btnLoadMore = document.getElementById('btnLoadMore');

// Extraction heuristics
function extractAsciiRuns(u8, minLen){
  const runs=[];
  let i=0;
  while(i<u8.length){
    if(isPrintable(u8[i])){
      const start=i;
      while(i<u8.length && isPrintable(u8[i])) i++;
      const len=i-start;
      if(len>=minLen) runs.push({offset:start,length:len,text:decodeAscii(u8.slice(start,i)),encoding:'ASCII'});
    } else {
      i++;
    }
  }
  return runs;
}
function extractUtf16leRuns(u8, minChars){
  const runs=[];
  let i=0;
  while(i+1<u8.length){
    if(isPrintable(u8[i]) && u8[i+1]===0){
      const start=i; let chars=0;
      while(i+1<u8.length && isPrintable(u8[i]) && u8[i+1]===0){ chars++; i+=2; }
      if(chars>=minChars){ const b=u8.slice(start,i); runs.push({offset:start,length:b.length,text:decodeUtf16le(b),encoding:'UTF-16LE'}); }
    } else i++;
  }
  return runs;
}
function extractLenPrefixed(u8, minLen){
  const runs=[];
  const view = new DataView(u8.buffer, u8.byteOffset, u8.byteLength);
  for(let i=0;i+4<u8.length;){
    const len = view.getUint32(i, true);
    if(len>=minLen && i+4+len <= u8.length){
      const slice = u8.slice(i+4, i+4+len);
      // quick printable ratio
      let printable=0; for(let b of slice) if(isPrintable(b)) printable++;
      if(slice.length>0 && printable/slice.length>0.6){
        runs.push({offset:i+4,length:slice.length,text:decodeAscii(slice),encoding:'LEN-PREF-ASCII',headerOffset:i});
        i += 4 + len; continue;
      }
    }
    i++;
  }
  return runs;
}

function uniqueByOffset(list){
  list.sort((a,b)=>a.offset - b.offset || b.length - a.length);
  const out=[]; const seen=new Set();
  for(const item of list){ if(!seen.has(item.offset)){ out.push(item); seen.add(item.offset); } }
  return out;
}

let _scanAbort = false;

async function scanBuffer(){
  if(!fileBuffer) return;
  _scanAbort = false;
  diag.textContent = 'Scanning (incremental) ‚Äî this keeps UI responsive...';
  segments = [];
  const u8 = fileBuffer;
  const total = u8.length;
  const minLen = Math.max(4, parseInt(minLenInput.value || '24', 10));
  const minUtfChars = Math.floor(minLen/2);

  // Parameters you can tweak:
  const YIELD_EVERY = 200000; // bytes processed before yielding back to UI
  const MAX_SEGMENTS = 200000; // safety cap to avoid runaway memory use
  const PREVIEW_CHARS = 1000; // how much of each segment to extract for the preview

  let i = 0;
  let processedSinceYield = 0;
  let found = 0;

  // Single-pass scan that detects UTF-16LE runs first (printable + 0x00) and ASCII runs
  while (i + 1 < total) {
    if (_scanAbort) { diag.textContent = 'Scan aborted.'; return; }

    // UTF-16LE heuristic: printable byte + 0x00 alternating
    if (isPrintable(u8[i]) && u8[i+1] === 0) {
      const start = i;
      let chars = 0;
      while (i + 1 < total && isPrintable(u8[i]) && u8[i+1] === 0) {
        chars++; i += 2;
        processedSinceYield += 2;
        if (processedSinceYield >= YIELD_EVERY) {
          processedSinceYield = 0;
          // update progress and yield
          diag.textContent = `Scanning (UTF-16LE) ${Math.floor(i/total*100)}% ‚Äî found ${found} segments...`;
          await new Promise(r => setTimeout(r, 0));
          if (_scanAbort) { diag.textContent = 'Scan aborted.'; return; }
        }
      }
      if (chars >= minUtfChars) {
        // only store preview now to avoid copying huge slices
        const length = chars * 2;
        const previewBytes = u8.slice(start, start + Math.min(length, PREVIEW_CHARS*2));
        segments.push({offset: start, length: length, encoding: 'UTF-16LE', previewBytes});
        found++;
        if (segments.length >= MAX_SEGMENTS) break;
      }
      continue; // we've advanced i already
    }

    // ASCII run
    if (isPrintable(u8[i])) {
      const start = i;
      while (i < total && isPrintable(u8[i])) { i++; processedSinceYield++; }
      const length = i - start;
      if (length >= minLen) {
        const previewBytes = u8.slice(start, start + Math.min(length, PREVIEW_CHARS));
        segments.push({offset: start, length: length, encoding: 'ASCII', previewBytes});
        found++;
        if (segments.length >= MAX_SEGMENTS) break;
      }
      if (processedSinceYield >= YIELD_EVERY) {
        processedSinceYield = 0;
        diag.textContent = `Scanning (ASCII) ${Math.floor(i/total*100)}% ‚Äî found ${found} segments...`;
        await new Promise(r => setTimeout(r, 0));
        if (_scanAbort) { diag.textContent = 'Scan aborted.'; return; }
      }
      continue;
    }

    // no run start ‚Äî advance one byte
    i++;
    processedSinceYield++;
    if (processedSinceYield >= YIELD_EVERY) {
      processedSinceYield = 0;
      diag.textContent = `Scanning ${Math.floor(i/total*100)}% ‚Äî found ${found} segments...`;
      await new Promise(r => setTimeout(r, 0));
      if (_scanAbort) { diag.textContent = 'Scan aborted.'; return; }
    }
  }

  // Finalize: convert previews to text (limited) and dedupe by offset
  for (const s of segments) {
    if (s.encoding === 'UTF-16LE') {
      s.text = decodeUtf16le(s.previewBytes);
    } else {
      s.text = decodeAscii(s.previewBytes);
    }
    // remove previewBytes to free memory
    delete s.previewBytes;
  }

  // dedupe & sort by offset (keep first occurrence)
  segments.sort((a,b) => a.offset - b.offset || b.length - a.length);
  const dedup = [];
  const seen = new Set();
  for (const it of segments) {
    if (!seen.has(it.offset)) { dedup.push(it); seen.add(it.offset); }
  }
  segments = dedup;

  diag.textContent = `Scan complete ‚Äî found ${segments.length} segments (showing first ${Math.min(displayLimit, segments.length)}).`;
  renderList();
}
 segments (deduped). Displaying first ${Math.min(displayLimit, segments.length)}.`;
    renderList();
  }, 20);
}

function renderList(){
  segList.innerHTML = '';
  const q = segSearch.value.trim().toLowerCase();
  let count=0;
  for(const s of segments){
    if(count>=displayLimit) break;
    const txtLower = (s.text||'').toLowerCase();
    const offHex = '0x'+s.offset.toString(16);
    if(q && !(txtLower.includes(q) || offHex.includes(q))) continue;
    const el = document.createElement('div'); el.className='seg';
    el.dataset.offset = s.offset;
    el.innerHTML = `<div style="font-family:monospace;font-size:12px;color:var(--muted)">0x${s.offset.toString(16)} ‚Ä¢ ${s.length} bytes ‚Ä¢ ${s.encoding}</div>
      <div class="preview" style="margin-top:6px;max-height:80px;white-space:pre-wrap">${escapeHtml(s.text.slice(0,400))}</div>`;
    el.addEventListener('click', ()=>selectSegment(s, el));
    segList.appendChild(el);
    count++;
  }
  if(count===0) segList.innerHTML='<div class="muted">No segments found</div>';
}

function escapeHtml(s){ return s.replace(/[&<>]/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;'}[c])); }

function selectSegment(s, el){
  document.querySelectorAll('.seg').forEach(x=>x.classList.remove('sel'));
  el.classList.add('sel');
  currentSelected = Object.assign({}, s);
  encLabel.textContent = s.encoding;
  selInfo.textContent = `0x${s.offset.toString(16)} ‚Ä¢ ${s.length} bytes`;
  // show full preview
  fullPreview.textContent = s.text;
  // put editable text
  if(s.encoding === 'UTF-16LE'){
    editArea.value = s.text;
  } else {
    editArea.value = s.text;
  }
}

// File input
fileInput.addEventListener('change', async (ev)=>{
  const f = ev.target.files[0];
  if(!f) return;
  fileInfo.textContent = `Loaded: ${f.name} (${f.size} bytes)`;
  const ab = await f.arrayBuffer();
  originalBuffer = ab.slice(0);
  fileBuffer = new Uint8Array(ab.slice(0));
  fileSizeLabel.textContent = fileBuffer.length.toString();
  diag.textContent = 'File loaded. Scanning...';
  scanBuffer();
});

btnSearchClear.addEventListener('click', ()=>{ segSearch.value=''; renderList(); });
segSearch.addEventListener('input', ()=>renderList());
btnRescan.addEventListener('click', ()=>{ if(fileBuffer) scanBuffer(); });

// Apply replacement (in-place or insert if allowGrow)
btnApply.addEventListener('click', ()=>{
  if(!currentSelected) return alert('Select a segment first');
  const newText = editArea.value || '';
  let newBytes;
  if(currentSelected.encoding === 'UTF-16LE') newBytes = encodeUtf16leStr(newText);
  else newBytes = encodeAsciiStr(newText);
  const origLen = currentSelected.length;
  if(newBytes.length <= origLen){
    // in-place replace and pad with zeros
    fileBuffer.set(newBytes, currentSelected.offset);
    if(newBytes.length < origLen) fileBuffer.fill(0, currentSelected.offset + newBytes.length, currentSelected.offset + origLen);
    diag.textContent = `Replaced in-place at 0x${currentSelected.offset.toString(16)} (was ${origLen} bytes, now ${newBytes.length}).`;
    // update segment text
    currentSelected.text = (currentSelected.encoding==='UTF-16LE') ? decodeUtf16le(fileBuffer.slice(currentSelected.offset, currentSelected.offset+origLen)) : decodeAscii(fileBuffer.slice(currentSelected.offset, currentSelected.offset+origLen));
    renderList();
    selectSegment(currentSelected, document.querySelector('.seg.sel'));
    fileSizeLabel.textContent = fileBuffer.length.toString();
    return;
  }
  // newBytes longer than original
  if(!allowGrow.checked){
    if(!confirm('New data is longer than original segment. To keep file structure safe, uncheck "Allow grow" to prevent insertion. Choose OK to proceed with insertion (this will shift later bytes).')) return;
  }
  // perform insertion (rebuild buffer)
  const delta = newBytes.length - origLen;
  const newBuf = new Uint8Array(fileBuffer.length + delta);
  // copy pre
  newBuf.set(fileBuffer.slice(0, currentSelected.offset), 0);
  // set new bytes
  newBuf.set(newBytes, currentSelected.offset);
  // copy post (skip original segment length)
  newBuf.set(fileBuffer.slice(currentSelected.offset + origLen), currentSelected.offset + newBytes.length);
  fileBuffer = newBuf;
  // update segments offsets after this offset
  for(const s of segments){ if(s.offset > currentSelected.offset){ s.offset += delta; } }
  currentSelected.length = newBytes.length; currentSelected.text = (currentSelected.encoding==='UTF-16LE') ? decodeUtf16le(fileBuffer.slice(currentSelected.offset, currentSelected.offset+currentSelected.length)) : decodeAscii(fileBuffer.slice(currentSelected.offset, currentSelected.offset+currentSelected.length));
  diag.textContent = `Inserted ${delta} bytes at 0x${currentSelected.offset.toString(16)} ‚Äî file rebuilt. Offsets adjusted.`;
  renderList();
  // reselect (find corresponding element)
  const el = Array.from(document.querySelectorAll('.seg')).find(x=>parseInt(x.dataset.offset,10)===currentSelected.offset);
  if(el) selectSegment(currentSelected, el);
  fileSizeLabel.textContent = fileBuffer.length.toString();
});

// Download patched file
btnDownload.addEventListener('click', ()=>{
  if(!fileBuffer) return alert('No file loaded');
  const blob = new Blob([fileBuffer], {type: 'application/octet-stream'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'global-metadata.dat';
  document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
});

// Revert
btnRevert.addEventListener('click', ()=>{
  if(!originalBuffer) return;
  if(!confirm('Revert all changes and reload original file buffer?')) return;
  fileBuffer = new Uint8Array(originalBuffer.slice(0));
  segments = [];
  currentSelected = null;
  fileSizeLabel.textContent = fileBuffer.length.toString();
  diag.textContent = 'Reverted to original file buffer. Rescanning...';
  scanBuffer();
});

// Extract all printable into a textarea (downloadable)
btnExtractAll.addEventListener('click', ()=>{
  if(!fileBuffer) return alert('No file loaded');
  const minLen = Math.max(4, parseInt(minLenInput.value||'24',10));
  const runs = extractAsciiRuns(fileBuffer, minLen).concat(extractUtf16leRuns(fileBuffer, Math.floor(minLen/2)));
  let out = '';
  for(const r of runs) out += `0x${r.offset.toString(16)} (${r.length}) [${r.encoding}]\n${r.text}\n\n`;
  const w = window.open('about:blank','_blank');
  w.document.write('<pre style="white-space:pre-wrap;font-family:monospace">'+escapeHtml(out)+'</pre>');
});

// Load more
btnLoadMore.addEventListener('click', ()=>{ displayLimit += 500; renderList(); });

// Hex edit toggle
let hexMode = false;
btnHexEdit.addEventListener('click', ()=>{
  if(!currentSelected) return alert('Select a segment first');
  if(!hexMode){
    // switch to hex view
    const bytes = fileBuffer.slice(currentSelected.offset, currentSelected.offset+currentSelected.length);
    editArea.value = Array.from(bytes).map(b=>b.toString(16).padStart(2,'0')).join(' ');
    btnHexEdit.textContent = 'Switch to text edit';
    hexMode = true;
  } else {
    // treat textarea as text
    btnHexEdit.textContent = 'Switch to hex edit';
    hexMode = false;
    // if user modified hex and clicks apply, we will parse hex in apply path
  }
});

// If user edits hex and clicks apply, detect hexMode and parse accordingly
// We'll intercept apply button click above by checking hexMode when building newBytes - handled implicitly if editArea used.

// initial state
diag.textContent = 'Ready. Load your global-metadata.dat.';
</script>
</body>
</html>
